\documentclass{report}

\usepackage{titletoc}
\usepackage{parskip}
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage{fontspec}
\usepackage{minted}

% Main font set so symbols display outside code blocks. You may not need this
\setmainfont[Ligatures=TeX]{Linux Libertine O}

% This font supports all logic symbols in monospace as far as I can tell. You may need to install
\setmonofont{DejaVu Sans Mono}

\graphicspath{ {/home/anna/workspace/EquivalencesApp/report/i/} }

\makeatletter
\def\@makechapterhead#1{%
  \vspace*{50\p@}%
  {\parindent \z@ \raggedright \normalfont
    \interlinepenalty\@M
    \Huge \bfseries #1\par\nobreak
    \vskip 40\p@
  }}
  \makeatother

\begin{document}
% This line removes red boxes from "incorrect syntax". Needs to be NOT in the pre-amble
\expandafter\def\csname PY@tok@err\endcsname{}

\title{Equivalence Teaching Tool}
\author{Anna Thomas}

\maketitle

\tableofcontents

\chapter{Introduction}

\section{Motivation}

All logics are based on propositional logic in some form, so it is important that new students learn how to use it. Propositional logic consists of syntax, semantics and proof theory; syntax is the formal language which is used to express concepts, semantics provide meaning for the language and proof theory provides a way to convert one formula into another using a defined set of rules.

We know that new students learning propositional logic can struggle to understand the rules and how they should be applied to formulae. To help with this our idea is to create an equivalence teaching tool; this will be a tablet application which will allow a user to apply rules to a formula until they have reached the desired equivalence.

\section{Approach}

We decided early on in the project that the tool should be an Android tablet application as opposed to a web or mobile one; this allows for an intuitive, interactive design while still having a large screen space.

The tool can be divided up into its main component parts: the parser, tree constructor, tree processing and tablet interface. The parser will be generated by the ANTLR4 parser generator, the tree constructor, processing code and the tablet interface will be written in Java with the interface using the Android SDK.

The parser requires a grammar to generate the relevant parser components. This will be used to parse the initial equivalence and return the ANTLR4 tree representation of the string.

The tree constructor is required to take the ANTLR4 representation of a tree and convert it into a more useful data structure which can be modified and displayed easily. The operators and atoms of the formula will be represented as nodes and leaves respectively.

Tree processing will be used to internally calculate which rules are applicable to each node and will allow us to subsequently manipulate the tree by applying these rules.

The interface will have an intuitive design displaying the current formula's formation tree (generated by the tree constructor) and allowing a user to click on the operators to apply a rule.


\section{Objectives}

The application should have some key features. These are outlined below:

\begin{enumerate}
\item Graphical tree representation of formulae

Representing the formula as a tree structure allows a user to see exactly how the formula should be read and can help them understand the order of operations. It also allows the user to click on an operator to select a rule for it; this is much more intuitive than just clicking on the whole formula and not knowing which section the rule would be applied to.

\item Undo/Redo functionality

Previous equivalent formulae will be displayed above the current formula. When an old formula is selected it will expand into tree form and the formulae below it are faded out \textit{(Undo)}. This will allow a user to perform rules on the old tree or select one of the later faded trees \textit{(Redo)}. When a rule is applied, the faded formulae will be removed from the history allowing the user to continue on from that point (Figure \ref{undo}).

\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth]{undo.png}
    \caption{Undo functionality - Clicking a previous equivalence shows the formula tree for that equivalence and sets the undone history as translucent. Applying a rule then overwrites the undone history.}
    \label{undo}
\end{figure}

\item Generated equivalences

We want to allow the user to have equivalences automatically generated for them to solve. This would be implemented by running the tool on a generated formula to give a significantly different equivalent one. The key advantage of having this feature as well as allowing manual entry of equivalences would be that the user will have a continuous supply of new equivalent logic formulae after completing all those set by their lecturer. This also requires generating the initial formula for the tool to be run upon or allowing the user to manually enter the first formula and have the second one generated for them.

\item Difficulty setting

Extending the idea of generated equivalences, we could allow the user to select a difficulty. This would be calculated by the length of the generated formula and how many rules were applied to get its equivalent formula. We could also provide a recommended difficulty based on how many previous equivalences they have completed and how far from optimal their solutions were.

\item Help

Providing the user with help is key to their improvement. Once an equivalence has been set up, the tool should calculate the optimal route from the starting formula to the desired end point. Upon finishing the equivalence the user will receive a message telling them how far from the optimal solution they were and give them the option to try again or to view the optimal solution. Throughout there will also be a help button available that will suggest the next step to the user on request; this includes the recommendation to undo certain steps if the user reaches a cycle. Pointing out mistakes could also be enabled, so if the user has completed a cycle or is heading towards a dead end they will be prompted to consider a different strategy.

\end{enumerate}

\section{Achievements}

%What is the problem, why is it interesting and whatâ€™s your main idea for solving it?

We have been challenged with developing an android application to help new students learn propositional logic and to complete logical equivalences. In this section we will discuss our motivation, approach and objectives.

\chapter{Logic}

We are assuming a basic understanding of propositional logic, including the operators and rules that are defined in the system. For more information on these please visit the Wikipedia article\cite{propositionalwiki}.

\section{Propositional Logic}

Propositional logic is a branch of logic that studies ways of combining and modifying whole sentences, statements or propositions to form more complex propositions. It is a formal system containing logical relations and properties which are derived from these methods of joining or altering statements.

A logical system contains three major parts:

\begin{enumerate}
\item Syntax - the formal language that is used to express concepts.
\item Semantics - provide meaning for the language.
\item Proof theory - provides a way to convert one formula into another using a defined set of rules.
\end{enumerate}

Logical definitions:

\begin{itemize}
\item \emph{Atomic} - A formula whose logical form is $\top$, $\bot$ or \textit{p} for an atom \textit{p}.
\item \emph{Negated atomic} - A formula of the form $\neg$\textit{p}.
\item \emph{Negated formula} - A formula of the form $\neg$\textit{A} for a formula \textit{A}.
\item \emph{Conjunction} - A formula of the form \textit{A}$\land$\textit{B}.
\item \emph{Disjunction} - A formula of the form \textit{A}$\lor$\textit{B}.
\item \emph{Implication} - A formula of the form \textit{A}$\to$\textit{B}, where \textit{A} is the \emph{antecedent} and \textit{B} is the \emph{consequent}.
\item \emph{Literal} - A formula that is either atomic or negated atomic.
\item \emph{Clause} - A disjunction of one or more literals.
\end{itemize}

A \textit{statement} is defined as a meaningful declarative sentence that is either true or false. For example, a statement could be: 

\begin{itemize}
\item `Socrates is a man.'
\item `All men live on Earth.'
\end{itemize}
A statement can be constructed of multiple parts, for example, the above statements can be combined into:

\begin{itemize}
\item `Socrates is a man and all men live on Earth.'
\end{itemize}
Each part of this statement can be considered a proposition. Propositional logic involves studying the connectives that join these such as \textit{`and'} and \textit{`or'} (to form conjunctions and disjunctions), the rules that determine the truth values of the propositions and what that means for the validity of the statement.

\section{First Order Logic}

\section{Truth tables}

It is necessary to understand the meanings of the symbols used in a language. Truth tables are mathematical tables used in logic to compute the functional values of logical expressions. They can be used to determine whether or not a propositional logic statement is logically valid.

A \textit{situation} determines whether each propositional atom is true or false. A truth table shows all the situations the input variables can be in. We write 1 for true and 0 for false as shown below:

\vspace{5 mm}
\begin{center}
  \begin{tabular}{ || c | c || c | c || }
    \hline
    A & B & A$\land$B & A$\lor$B \\ \hline
    1 & 1 & 1 & 1 \\
    1 & 0 & 0 & 1\\
    0 & 1 & 0 & 1 \\
    0 & 0 & 0 & 0 \\
    \hline
  \end{tabular}
\end{center}
\vspace{5 mm}

Truth tables can be used to define any operators, including any new ones which might be desired.

\chapter{Related Work}

\section{Logic Daemon}

Created in Texas A\&M University, the Logic Daemon\cite{logicdaemon} is an online logic proof checker. It comprises a simple web page with two small text input boxes for the premises and conclusion and then one large text box for applying primitive rules (Figure: \ref{logicdaemon}).

While this tool does allow us to apply rules to prove equivalences we do not find it very intuitive to use at all. The interface itself looks quite unclear and isn't user friendly so it would not be suited to new students. Applying the rules to the premises is also quite confusing as it shows all the rules and does not alert the user to the fact they cannot be applied until they have already clicked on it. We found this a frustrating way of attempting a proof; as such, we intend to only display the rules that can be applied in the current situation.

However, it is a useful tool for those more knowledgeable about logic for checking proofs once they have got to grips with the interface. It also has a \textit{`Get Help'} button to suggest which rule to use next. We hope to use the idea of a help button in our project but to build upon it in order to provide more extensive help such as showing when an action has been repeated (i.e. a cycle has been reached).

We hope that our tool will be more intuitive to use because we will display formulae as formation trees with interactive nodes to apply rules with. This should provide a more straight forward way of presenting the rules to new students.

The website also provides a simple equivalence checker, well-formed formula checker and countermodel checker. These are all similar tools useful in logic but again the interface is not particularly intuitive or user friendly.

The Logic Daemon tool also provides support for first order logic which we are not planning on covering in our main tool. However, this could be implemented as an extension at the end of our project.

\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth]{logicdaemon.png}
    \caption{Logic Daemon}
    \label{logicdaemon}
\end{figure}

\section{Pandora}

Pandora\cite{pandora} is a tool created by Imperial College London; it stands for `Proof Assistant for Natural Deduction using Organised Rectangular Areas'. It can be used to prove that a goal formula follows from the given formulae. Pandora allows the user to repeatedly apply natural deduction rules (Figure: \ref{pandora}).

We do not intend to include natural deduction in our tool as we want to focus more on solving propositional logic equivalences. Pandora is a much nicer tool than the Logic Daemon and we find it much more intuitive and easy to use.

Pandora allows a user to apply rules forwards or backwards. We know from using Pandora that some proofs are easier to complete working backwards; as such, this is an idea we hope to incorporate into our tool by allowing the user to expand either the top or bottom formula to show its formation tree and to apply rules. 

\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth]{pandora.jpg}
    \caption{Pandora}
    \label{pandora}
\end{figure}

\section{Logic Solver}

This is an Android application to show truth tables and possible logical equivalences. It looks like it has been made as a phone application as on a tablet it fills very little of the screen and it is difficult to click on some of the links (Figure \ref{logicsolver}).

The user can apply rules to the formula they enter into the application; this is done by selecting the rule they want out of a list which is then applied to the formula. However they cannot use this application to solve an equivalence as they can only enter one formula and then apply rules to that. We want to improve upon this in our own application by allowing the user to enter two formulae and work from either end to solve it.

The list of rules that is offered to the user only shows the rules that can be applied to the current formula. We want to also offer this behaviour as there are far too many rules to display them all to the user and expect them to sort through which could be applied.

Formulae are displayed simply in the application; we think this could be improved upon and want to display our current formula as its formation tree.

\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth]{logicsolver.png}
    \caption{Logic Solver Android Application}
    \label{logicsolver}
\end{figure}

\section{Truth Tables}

Truth Tables is also an Android application mainly for use on a phone. It simply generates and displays truth tables based on a logical formula (Figure \ref{truthtables}).

We currently do not plan on adding truth tables to our application as we do not believe it is as useful for learning and understanding propositional logic as our other ideas. However, this could be added as an extension at the end of the project depending on how much time is left.

\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth]{truthtables.png}
    \caption{Truth Tables Android Application}
    \label{truthtables}
\end{figure}

\section{LogicCalc}

LogicCalc is an Android application for solving problems with propositional logic. It allows the user to create workbooks to save and print their proofs (Figure \ref{logiccalcapp}). However we had trouble running it on our Nexus tablet.

We like the idea of saving proofs in workbooks for future reference. This is something we had not considered before and are curious to explore as an extension. This functionality would be useful for students completing exercises that needed a paper hand in as they would be able to save and print them off.

\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth]{logiccalcapp.png}
    \caption{LogicCalc Android Application}
    \label{logiccalcapp}
\end{figure}

\section{Propositional Logic Calculator}

The Propositional Logic Calculator\cite{logiccalc} finds all of the models of a given propositional formula. The website tells us that the only limitation for this calculator is that we have only three atomic propositions to choose from: p,q and r (Figure: \ref{logiccalc}).

Propositions are entered using the keyboard they provide on the calculator and the reasoning process is initiated by clicking `ENTER'. It then calculates the truth value assignments that will make the formula true in the `MODELS' section and the truth value assignments making the formula false in the `COUNTERMODELS' section.

This tool is used simply for calculating truth values of a formula. We will not be implementing this in our equivalences tool because we do not think that knowing the truth values for a formula is as useful for learning and understanding propositional logic as our other ideas.

\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth]{logiccalc.png}
    \caption{Propositional Logic Calculator}
    \label{logiccalc}
\end{figure}

\section{Previous Year Projects}

Once we have made more progress on our tool we will look into finding out what previous years did when they were assigned similar projects. We do not want to look into these this early in the project so we can generate our own implementation ideas as these projects will be very similar to ours.

\chapter{Parser}
\section{Parser Generation}

A parser generator is a tool which creates a parser from an inputted grammar. This is necessary so that we can parse the logic equivalences entered in to our application and create an internal tree representation.

\subsection{ANTLR4}

ANTLR is a widely used powerful parser generator that can be used to read, process, execute or translate structured text. It is used by a variety of companies such as Twitter for query parsing and Hadoop in data analysis systems. ANTLR supports a wide range of languages including Java making it a very suitable choice for our project.

From a grammar ANTLR generates a parser for that language and has the ability to automatically build parse trees representing the input. More interestingly, ANTLR also generates tree walkers which can be customised to visit the nodes of those trees and perform actions on those nodes. We use this functionality to build our own custom tree as described in Section \ref{sub:walker}.

ANTLR uses EBNF for its input grammar notation and uses an LL(*) parsing algorithm. This allows direct left recursion so that expressing our required syntax is easy and natural. 

\subsection{Alternatives to ANTLR4}
\label{sub:alternatives_to_antlr4}

ANTLR4 provides many benefits over previous versions and alternatives. ANTLR4 uses a new variation of the LL(*) parsing algorithm that was used in ANTLR3. It uses an adaptive algorithm that is much stronger than the static grammar analysis algorithm used in ANTLR3. This means that ANTLR4 will accept much more natural looking grammars and provides a lot more flexibility than in previous versions. The ability to write much more natural expression rules increases the usability as in previous versions it was often a struggle to write a grammar that ANTLR would accept. ANTLR4 aimed to focus more on ease-of-use and chose simplicity over complexity where possible. This is a large reason for choosing this parser generator over the alternatives.

Although there are a few other tools that can generate source code similar to ANTLR that you can load into a debugger and step through, none of them have adaptive LL(*) parsers as ANTLR4 does. Which means if we chose an alternative such as JavaCC we would need to configure our grammar to suit a weaker LL(k) parsing strategy. JavaCC is limited to the LL(k) class of grammars because it generates top-down parsers which means left recursion cannot be used. This would make generating the grammar more difficult and the result appear less natural.

Through our research we established that ANTLR4 provided the most sophisticated and easy-to-use parser generator for our project.

\section{Grammar}

\subsection{Propositional Logic}

The grammar we use with ANTLR can be seen in Listing \ref{expr.g4}. We only use propositional atoms between `a' and `r' because we don't need a whole alphabet of variables available and extending it to the whole alphabet would cause confusion with the logical or (`$\lor$') symbol. 

\begin{listing}[ht]
\begin{minted}[mathescape, frame=lines]{antlr}
grammar Expr;	

prog: expr;

expr: '(' expr ')'          #EXPR
    | 'Â¬' expr              #NOT
    | expr BINOP expr       #BINOP_
    | expr 'â†’' expr         #IMPLIES
    | expr 'â†”' expr         #IFF
    | ATOM                  #ATOM_
    |                       #ERROR
    ;

BINOP: ('âˆ§' | 'âˆ¨');
ATOM:  ('a'..'r' | 'âŠ¤' | 'âŠ¥');

\end{minted}
\caption{Expr.g4 grammar for Propositional Logic to be used by ANTLR}
\label{expr.g4}
\end{listing}

\subsection{Order of Precedence}

Precedence rules can be used as a way of reducing the number of necessary parentheses. We use these in our grammar to decide which connective is the main connective when parsing a non-atomic formula. The precedence of logical operators is defined in Table \ref{orderofprecendence}.

\begin{table}[h]
\begin{center}
\begin{tabular}{|| c | c ||}
    \hline
    Operator & Precedence \\ \hline 
    $\lnot$  & 1 \\
    $\land$  & 2 \\
    $\lor$   & 3 \\
    $\to$    & 4 \\
    $\leftrightarrow$ & 5 \\ \hline
\end{tabular}
\caption{Order of Precedence for Propositional Logic}
\label{orderofprecendence}
\end{center}
\end{table}

\subsection{Parser, Lexer and Walker}
\label{sub:walker}

ANTLR automatically generates a parser and lexer for the grammar. The lexer tokenises the input source (the logical formula) into a token stream which can then be passed to the parser. A parse tree is generated by the parser which can be walked through by a custom walker. 

The custom walker extends the ANTLR generated listener to define methods for when the parser enters each rule defined in the grammar. For example, when the parser enters the {\tt NOT} rule, {\tt enterNOT()} is called. Equally, when that rule is exitted, {\tt exitNOT()} is called. This allows us to walk through the parse tree and create our custom tree as we go.

An empty {\tt FormationTree} is passed through to the walker alongside the parse tree so the walker can build the tree up as the parse tree is walked through. Each time a grammar rule is entered the appropriate method in the walker is called to create that node in our tree. The structure of the tree is defined in more detail in Section \ref{sec:formation_tree}.

\subsection{Error Handling}

ANTLR provides an {\tt ANTLRErrorStrategy} interface for implementing a custom error handler to deal with syntax errors encountered during a parse by ANTLR-generated parsers. However, this has limited documentation and is a complex feature. Therefore, we have opted to relax the grammar by defining an error case so we can treat incorrect syntax as a semantic error instead.

As shown in Listing \ref{expr.g4} we define an {\tt ERROR} case which accepts any incorrect syntax. Once parsing is complete we walk over the tree using an {\tt ExprWalker} (described in Section \ref{sub:walker}) and when an error case is entered we can set an error flag in the tree. This enables us to manage the error later by displaying an error message to the user without the application throwing up errors.

\subsection{Extension to First Order Logic}

\chapter{Internal Tree Representation}

\section{Compiler}
\label{sec:compiler}

The compiler combines all of the generated and custom parts of the parser. We define a {\tt compile()} method to take the logic formula as input and parse it to create its tree representation. This is shown in Listing \ref{compile()}.

\begin{listing}[ht]
\begin{minted}{java}
public FormationTree compile(String expr) {
    CharStream input = new ANTLRInputStream(expr);
    ExprLexer lexer = new ExprLexer(input);
    CommonTokenStream tokens = new CommonTokenStream(lexer);
    ExprParser parser = new ExprParser(tokens);
    
    FormationTree tree = new FormationTree(null);
    ParseTree parseTree = parser.prog();
    
    ParseTreeWalker walker = new ParseTreeWalker();
    walker.walk(new ExprWalker(tree), parseTree);

    return tree;
}
\end{minted}
\caption{compile() function to convert a logical formula into a FormationTree}
\label{compile()}
\end{listing}

\section{Formation Tree}
\label{sec:formation_tree}

\subsection{Node indexing - proof no two nodes can have the same depth and key}
\subsection{Tree operations, eg. adding a new node}

\section{Nodes}
\subsection{Binary Operators}
\subsection{Unary Operators}
\subsection{Atoms}

\chapter{Tree Manipulation}
\section{The Rule Engine}
\label{sec:the_rule_engine}

\section{Rule Selection - which rules can be applied to a node}
\section{Rule Application - how rules are applied to a node}
\section{Random Rule Application}
\subsection{Generating equivalent formulae}

\chapter{Android VS Web Applications}

\section{Android vs Web app}
\subsection{Intuitive to use}
\subsection{Learning experience}
\subsection{None currently available for Android}

\section{Tablet vs Phone app}
\subsection{Screensize}
\subsection{Formation Tree would not feasible on phone app}

\chapter{Android}

\section{Technical Background}

\section{Features}

\subsection{Multi-Touch Gestures}


Android is an operating system based on the Linux kernel which was designed primarily for touchscreen mobile devices such as smartphones and tablet computers\cite{androidwiki}.

The user interface is based around direct manipulation. This means using touch inputs that loosely correspond to real-world actions, for example swiping, tapping and pinching to control items on screen. The response to user actions is designed to be immediate and provides a fluid touch interface. It often provides haptic feedback (forces, vibrations or motions) to the user using the vibration capabilities.

Android takes advantage of internal hardware such as accelerometers, gyroscopes and proximity sensors in some applications to respond to other user actions, such as re-orientating the screen from portrait to landscape.

\section{Market Share}

Android's main competitor in the mobile platform market is Apple's iOS. In research conducted in the fourth quarter of 2012, Kantar Worldpanel Comtech showed sales of all Android smartphones worldwide outpacing the iPhone by a huge margin: 70 percent to 21 percent of the smartphone market\cite{androidstats}.

In the tablet market the iPad dominated Android's $7\verb+"+$ tablets with 53.8 percent to 42.7, which is lower than Android's smartphone market but steadily increasing.

\chapter{The App}
\section{Truth Tables}
\subsection{Ensure equivalences are equal before beginning}

\section{Random Generation of Equivalences}
\subsection{Generating single equivalence}
\subsection{Generate equivalence formula - repeated application of random rules}

\section{Custom Keyboard}
\subsection{Logic symbols and variables}

\section{Undo/Redo Functionality}
\subsection{Stack of trees maintained}
\subsection{OnClick listeners}

\section{Formation Tree Representation}

\subsection{The Formation Tree}

Each logical connective in an formula can be written enclosed in parentheses. For example:

\begin{center}
(a$\to$b)$\land$$\neg$a \ can be written as \ ((a$\to$b)$\land$($\neg$a))
\end{center}

Due to this property we can create a binary tree unique to each proposition; this is called a formation tree. Each connective and propositional atom is represented by a node and a leaf respectively. This provides a clear and attractive way of displaying the formula but is too expensive for every day use. In our application we wish to display the formation tree of the current equivalences.

Displaying the formation trees allows a user to see an interactive representation of the equivalences where touching the nodes and leaves in the tree allows the user to apply rules to various parts of the tree.

\subsection{The NP-Complete Problem}

When planning to draw the formation trees to the app we assumed there would be a simple, classic algorithm for drawing neat, aesthetically pleasing trees. However, we discovered the problem was not that simple. Drawing an attractive Tree layout is an NP-complete problem\cite{npcompletetrees} and there are many tree-drawing algorithms attempting to solve the problem of drawing attractive trees. We reviewed many of these algorithms to find one suitable to use.

\subsection{What Makes An Attractive Tree?}

Although generating an attractive tree is a matter of taste, certain principles are widely agreed upon to be key to drawing an aesthetically pleasing tree. The first three are taken from Wetherell and Shannon's tree drawing algorithm for producing tidy drawings using the smallest width possible\cite{tidierdrawingsws}.

\textbf{Aesthetic 1}: Nodes at the same level of the tree should lie along a straight line, and the straight lines defining the levels should be parallel. 

\textbf{Aesthetic 2}: A left son should be positioned to the left of its father and a right son to the right.

\textbf{Aesthetic 3}: A father should be centered over its sons.

Although not mentioned in the original article, Aesthetic 1 was also meant to guarantee the edges in the tree do not intersect except at the nodes by requiring that the relative order of nodes over any level be the same as the level order traversal of the tree. Wetherall and Shannon's algorithm is fairly basic and has a deficiency that compromises the overall attractiveness of the resulting tree. It produces drawings that could be made narrower within the constraints of the aesthetics and are not entirely pleasing to the eye - nodes in certain subtrees are drawn too far apart due to the fact that their shape is influenced by the positioning of nodes outside that subtree. This leads to the asymmetry of the resulting tree. Therefore when Reingold and Tilford\cite{tidierdrawingsrt} set out to create a better tree drawing algorithm they introduced a fourth aesthetic:

\textbf{Aesthetic 4}: A tree and its mirror image should produce drawings that are reflections of one another; moreover, a subtree should be drawn the same way regardless of where it occurs in the tree.

Fulfilling this aesthetic requires us breaking Wetherell and Shannon's aim of minimum width so that all all isomorphic subtrees are drawn the same. This is considered a more important principle than using the minimum width as our main aim is to create an attractive tree. This is an acceptable drawback as Supowit and Reingold proved that determining the minimum width under these aesthetics is NP-hard\cite{complexityofdrawingtreesnicely}. Therefore, we can use Reingold and Tilford's algorithm to draw our formation tree to produce an attractive result. 

\subsection{Reingold and Tilford's Algorithm}

The proposed algorithm was based on the following heuristic: 

``Two subtrees of a node should be formed independently, and then places as close together as possble''\cite{tidierdrawingsws}.

This is applied during a postorder traversal of the tree by taking the two subtrees of a node and calculating the contours of those subtrees. The two subtrees are then positioned so they overlap at their roots before moving them apart until no two points are touching. This is done recursively at each level moving down the levels of the tree until the bottom of the shortest subtree is reached. Once the process is finished the position of the subtrees can be fixed relative to their parent node which is centered over them. Once the postorder traversal is complete a preorder traversal occurs to convert the relative positions to absolute coordinates.

\subsection{Walker's Algorithm}

Extending Reingold and Tilford's algorithm to to rooted ordered trees of unbounded degree as described in their paper produces layouts where some subtrees of the tree could have been dispersed better to create a more attractive layout. In 1990 Walker's algorithm solved this problem by spacing out subtrees whenever possible, however in the initial algorithm presented the runtime was quadratic. Walker's algorithm was improved upon by Christoph Buchheim, Michael J\"unger and Sebastian Leipert so it would run in linear time\cite{improvingwalkers}. This is the algorithm we use in our application. 

\subsection{Abego TreeLayout}

Abego TreeLayout is an external library which efficiently creates compact and highly cusomisable tree layouts. It is based on Walker's algorithm with the enhancements previously mentioned suggested by Buchheim, J\"unger, and Leipert\cite{treelayoutlineartime}. The software builds tree layouts in linear time so that even trees with many nodes are built quickly. TreeLayout separates the layout of the tree from the actual rendering, therefore it is suitable for drawing trees in an Android application because it is not limited to a specific output or format.

\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth]{abegolineartime.png}
    \caption{Illustrates the linear time behaviour of the Abego TreeLayout algorithm\cite{abegolineartime} and shows the applicability for large numbers of nodes.}
    \label{abegolineartime}
\end{figure}

\subsection{Drawing the Formation Tree}

We created a custom view DrawView to draw the trees to the screen in the application. This is created by simply extending the Android View class and overriding the {\tt onDraw()} function. To add a custom view to our user interface we also need to define custom attributes in a resource element as shown in Listing \ref{drawviewxml}.

\begin{listing}[ht]
\begin{minted}{xml}
<declare-styleable name='DrawView'>
    <attr name='showTree' format='boolean' />
</declare-styleable>
\end{minted}
\caption{DrawView resource element}
\label{drawviewxml}
\end{listing}

In {\tt onDraw()} we determine whether we are drawing the top or bottom formation tree and call {\tt setUpTreeLayout()} (shown in Listing \ref{setuptreelayout}) which uses the Abego TreeLayout to manage the layout.

To use TreeLayout we create a {\tt TreeLayout} instance with our tree (accessible through the {\tt TreeForTreeLayout} inferface), a {\tt FixedNodeExtentProvider} (defines a fixed size for each node) and a {\tt DefaultConfiguration} (configures the layout by defining parameters such as {\tt gapBetweenNodes} and {\tt gapBetweenLevels}).

\begin{listing}[ht]
\begin{minted}{java}
public void setUpTreeLayout(Location location) {
    DefaultConfiguration<Node> configuration = new 
            DefaultConfiguration<Node>(gapBetweenLevels, 
            gapBetweenNodes, location);

    FixedNodeExtentProvider<Node> nodeExtentProvider = new 
            FixedNodeExtentProvider<>(20, 20);
    treeLayout = new TreeLayout<Node>(tree,
            nodeExtentProvider, configuration);

    ...
}
\end{minted}
\caption{setUpTreeLayout() is called by onDraw() in DrawView}
\label{setuptreelayout}
\end{listing}

TreeLayout calculates the position of each node so we can then paint the nodes and edges to the screen using Android Canvas.

\subsection{Responding to Touch Events}

By overriding {\tt onTouchEvent()} in DrawView we can get the event action performed on the view. Using this we can check if the touched position is within the bounds of any of the nodes drawn to the screen. If the position is within the bounds of a node we display applicable rules for that node by calling {\tt setRules()} on the current activity ({\tt BeginEquivalenceActivity}). Selecting a node also forces a redraw so that we can highlight the selected node.

\section{Rule Application}

\subsection{Rule Display}

The rules are displayed in a PopupMenu on screen either above or below the selected tree. The rules are generated by the {\tt RuleEngine} as described in Section \ref{sec:the_rule_engine}.

Calling {\tt setRules()} adds the generated rules iteratively to the PopupMenu. If the rule requires user input (eg. $\top := \bot \to a$) a SubMenu is created with the variables that can be applied as shown in Listing \ref{rulessetup}. Each entry in the PopupMenu contains the String representing the rule and the rule key. The key is required so we know which rule to apply on touch events.

\begin{listing}[ht]
\begin{minted}{java}
public void setRules(SparseArray<String> rules, Node selected, 
        FormationTree selectedTree) {
    ...

    int key;
    for (int i = 0; i < rules.size(); ++i) {
        key = rules.keyAt(i);

        if (key < min_user_input_required) {
            rulesList.getMenu().add(Menu.NONE, key, Menu.NONE, 
                    rules.get(key));
        } else {
            SubMenu sub = rulesList.getMenu().addSubMenu(Menu.NONE, 
                    key, Menu.NONE, rules.get(key));
            SortedSet<String> vars = topTree.getVariables();
            vars.addAll(bottomTree.getVariables());

            for (String v : vars) {
                sub.add(Menu.NONE, key, Menu.NONE, rules.get(key) 
                        + " using " + v);
            }
        }
    }
    rulesList.show();
}
\end{minted}
\caption{Rules being added to the rulesList PopupMenu in setRules}
\label{rulessetup}
\end{listing}

\subsection{Responding to PopupMenu Touch Events}
\label{sub:responding_to_popupmenu_touch_events}

Overriding {\tt onMenuItemClick()} in {\tt BeginEquivalenceActivity} allows us to determine which item was selected from the PopupMenu and and apply that rule to the selected node. We can determine which rule should be applied by taking the key of selected item and applying that rule from our BitSet of rules using the {\tt RuleEngine} as described in Section \ref{sec:the_rule_engine}.

Applying a rule to the selected node adds a new TextView to the respective list of equivalences (either top or bottom). Once the rule has been applied the application will check for completion and cycles (described in Section \ref{sub:detecting_cycles}). If either are found a Toast (a simple popup for displaying feedback) will be displayed alerting the user.

We also override {\tt onDimiss()} so that when a user dismisses the PopupMenu without selecting a rule we can also redraw the formation tree to deselect the selected node. 

\section{Difficulty}
\subsection{Length of generated equivalences}
\subsection{Number of variables/operators}
\subsection{Number of rules different}

\section{Help}
\subsection{Detecting cycles}
\label{sub:detecting_cycles}

\begin{comment}
\chapter{Project Plan}

\section{Progress}

\begin{enumerate}
\item Grammar and parser generator - We have created a grammar written in ANTLR4 to define the parser generator. This can take an input formula, parse it, and convert it into a tree structure that we can manipulate.
\end{enumerate}

\section{Future Plan}

Targets for March 28th (End of second term):

\begin{enumerate}
\item Tree Constructor - We need to convert the tree generated by the parser into a more useful data structure. This will be a tree where the nodes and leaves are operators and propositional atoms respectively.
\item Tree Processing - Once we have a useful data structure, we can begin manipulating it with logical rules. This will make up the internal functionality of the application. For this we will need to design some specific algorithms, for example:

\begin{itemize}
\item Rule calculator - Calculate which rules are applicable to each operator
\item Subtree manipulator - Replace subtrees based on the rule that is applied to the operator
\end{itemize}

\item Basic android interface - We will create a basic interactive interface to allow the user to enter an equivalence, display the current equivalence and apply the tree manipulation algorithms we have created. This will not display the formulae as trees yet, as we anticipate the layout will be fairly complex to design to be aesthetically pleasing.
\end{enumerate}

The goal of the rule generator is not only to generate rules to apply to the current formula but to also determine the optimal number of rules to complete the equivalence. This will be used in for generating equivalences, helping the user and spotting mistakes.

Targets for 3rd term:

\begin{enumerate}
\item Android Tree Layout - We need to design a layout algorithm (or adapt an existing one) to display the current formula as a tree so that the whole tree will be visible on the tablet as well as allowing for space for the lines of other equivalences.
\item Formula Generator - The user should be able to generate equivalences on demand to practice with as well as inputting them manually. This will function by generating an initial equation, then randomly applying a number of valid rules to the equation. This should check for cycles so that the second formula is not too similar to the first.
\item Extensions:

\begin{itemize}
\item Undo Functionality - We want the user to have the ability to undo previous rules and view the tree of a previous equivalence. When the user selects a previous equivalence they should be able to redo any steps until they decide to apply a new rule, in which case the undone history will be lost. This will be implemented by maintaining a stack for each of undo and redo.
\item Help - We want to create a help tool that uses the rule calculator to determine the optimal path from one equivalence to another. This will be used to:

\begin{itemize}
\item On request tell the user what the next optimal step is. It should generate the optimal path from their \textit{current} formula so the calculation can either be run whenever the user requests help or every step depending on how computationally expensive it is.
\item Calculate how far from the optimal path they are once they have completed the equivalence.
\item Detect if the user has made a mistake such as completing a cycle or heading towards a dead-end and prompt them.
\end{itemize}
  
\item Difficulty Settings - We want to set difficulty in a variety of ways, these include:

\begin{itemize}
\item When generating equivalences, the start formula length can be varied and rules can be applied more or fewer times depending on difficulty.
\item No help functionality for higher difficulties.
\item There is also the possibility of recommending a difficulty for the user based on how many previous equivalences they have completed, or how close their solutions have been to the optimum.
\end{itemize}

\item Extra operators - New operators could be added to the grammar such as XOR and NAND. These could be implemented as a separate grammar and they are likely to be used separately from the standard set of operators.
\end{itemize}

\end{enumerate}

\end{comment}

\chapter{Evaluation}
\section{Testing}
\subsection{JUnit tests}
\subsection{Survey - People who do/don't understand logic}

\section{Performance}

Once the application has been built we will need to find a way to test that it has met the objectives we set out to achieve. The main objective is to create an intuitive Android application that helps students improve in solving equivalences; as such, we will survey a wide range of test subjects. These tests will be split into two groups: people who understand logic and equivalences well and people who are new to propositional logic.

We need to ask people who understand logic (e.g. lecturers) so we can confirm that it works as a teaching tool. People who are new to logic (e.g. first year students) are necessary so we can evaluate how effective it is as a learning tool. This can be carried out through asking the target groups to use the application and provide feedback.

\chapter{Conclusions}
\section{Completed objectives}
\section{Comparisons to related work}

\chapter{Future Work}
\section{Improvements to completed objectives}

\section{Device support}
\subsection{Reduced app without trees for phones}

\section{More complex help}
\subsection{Calculating the optimal route}
\subsection{Suggested next move}
\subsection{Future dead end detection}

\section{First Order Logic}
\subsection{Extend grammar}
\subsection{Add and handle new rules}

\begin{thebibliography}{9}

\bibitem{propositionalwiki}
  Wikipedia,
  \emph{Propositional Logic}.
  http://en.wikipedia.org/wiki/Propositional\_calculus

\bibitem{propositionaliep}
  IEP,
  \emph{Propositional Logic}.
  http://www.iep.utm.edu/prop-log

\bibitem{androidwiki}
  Wikipedia,
  \emph{Android (Operating System)}.
  http://en.wikipedia.org/wiki/\\Android\_(operating\_system)

\bibitem{androidstats}
  Harry McCracken,
  \emph{Whoâ€™s Winning, iOS or Android?}.
  http://techland.time\\.com/2013/04/16/ios-vs-android

\bibitem{logicdaemon}
  Colin Allen, Chris Menzel,
  \emph{Logic Daemon}.
  http://logic.tamu.edu

\bibitem{pandora}
  Imperial College London,
  \emph{Pandora}.
  http://www.doc.ic.ac.uk/pandora/newpandora/\\index.html

\bibitem{logiccalc}
  Enrico Franconi,
  \emph{Propositional Logic Calculator}.
  http://www.inf.unibz.it/\\\textasciitilde franconi/teaching/propcalc

\bibitem{tidierdrawingsws}
  C. Wetherell and A. Shannon,
  \emph{Tidier Drawings of Trees}.
  IEEE Trans. Software Eng., 
  vol SE-5, pp. 514-520.
  1979.

\bibitem{tidierdrawingsrt}
  Edward M. Reingold and John S. Tilford,
  \emph{Tidier Drawings of Trees}.
  IEEE Transactions on Software Engineering, 
  vol SE-7, no. 2,
  March 1981.

\bibitem{complexityofdrawingtreesnicely}
  Kenneth J. Supowit and Edward M. Reingold
  \emph{The Complexity of Drawing Trees Nicely}
  vol 18, issue. 4, pp 377-392,
  January 1983.

\bibitem{npcompletetrees}
  K. Marriott, 
  \emph{NP-Completeness of Minimal Width Unordered Tree Layout}, 
  Journal of Graph Algorithms and Applications, 
  vol. 8, no. 3, pp. 295-312 (2004).
  http://www.emis.de/journals/JGAA/accepted/2004/MarriottStuckey2004.8.3.pdf

\bibitem{presentabletrees}
  Bill Mill,
  \emph{Drawing Presentable Trees}.
  http://billmill.org/pymag-trees

\bibitem{improvingwalkers}
  Buchheim C, J\"unger M, Leipert S. 
  \emph{Improving Walker's Algorithm to Run in Linear Time}
  Graph Drawing Lecture Notes in Computer Science Volume 2528, 
  2002, pp 344-353

\bibitem{treelayoutlineartime}
  Buchheim C, J\"unger M, Leipert S. 
  \emph{Drawing rooted trees in linear time}. 
  Softwareâ€”Practice and Experience 2006; 36(6):651â€“665

\bibitem{abegolineartime}
  \emph{Abego TreeLayout}
  https://code.google.com/p/treelayout/

\end{thebibliography}

\chapter{User Guide}
\section{How to use the app}

\end{document}